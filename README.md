# b3c
NEW change
chainparams.cpp
// Copyright (c) 2010 Satoshi Nakamoto
// Copyright (c) 2009-2020 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <chainparams.h>

#include <chainparamsseeds.h>
#include <consensus/merkle.h>
#include <hash.h> // for signet block challenge hash
#include <util/system.h>
#include <versionbitsinfo.h>

#include <assert.h>

#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>

static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesisOutputScript, uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)
{
    CMutableTransaction txNew;
    txNew.nVersion = 1;
    txNew.vin.resize(1);
    txNew.vout.resize(1);
    txNew.vin[0].scriptSig = CScript() << 486604799 << CScriptNum(4) << std::vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
    txNew.vout[0].nValue = genesisReward;
    txNew.vout[0].scriptPubKey = genesisOutputScript;

    CBlock genesis;
    genesis.nTime    = nTime;
    genesis.nBits    = nBits;
    genesis.nNonce   = nNonce;
    genesis.nVersion = nVersion;
    genesis.vtx.push_back(MakeTransactionRef(std::move(txNew)));
    genesis.hashPrevBlock.SetNull();
    genesis.hashMerkleRoot = BlockMerkleRoot(genesis);
    return genesis;
}

/**
 * Build the genesis block. Note that the output of its generation
 * transaction cannot be spent since it did not originally exist in the
 * database.
 *
 * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)
 *   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)
 *     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)
 *     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)
 *   vMerkleTree: 4a5e1e
 */
static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)
{
    const char* pszTimestamp = "Financial independent.A counterbalance to the global debt grow has been found..";//clone new message
    const CScript genesisOutputScript = CScript() << ParseHex("04127af709c0738b33490059eb2c801199d4e9156eefd64082b948aed4fbf6db0d5272a21df1f5c9e74802dba32ba5574fbe9fec24d6811c3b16d1ad6055909af9") << OP_CHECKSIG;//clone new pubkey
    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);
}

/**
 * Main network
 */
class CMainParams : public CChainParams {
public:
    CMainParams() {
        strNetworkID = CBaseChainParams::MAIN;
        consensus.signet_blocks = false;
        consensus.signet_challenge.clear();
        consensus.nSubsidyHalvingInterval = 210000;
        consensus.BIP16Exception = uint256S("0x00000000d0c68340079b33f213c1825928c1b956d11748267a6b0f9511712ce1");//genesis hash clone
        consensus.BIP34Height = 0;//start bip block clone
        consensus.BIP34Hash = uint256S("0x00000000d0c68340079b33f213c1825928c1b956d11748267a6b0f9511712ce1");//genesis hash clone
        consensus.BIP65Height = 0; // clone height block
        consensus.BIP66Height = 0; // clone height block
        consensus.CSVHeight = 0; // clone height block
        consensus.SegwitHeight = 481824; // clone height block 0 or 1 not work in start save as is 
        consensus.MinBIP9WarningHeight = 483840; // segwit activation height + miner confirmation window  clone height block
        consensus.powLimit = uint256S("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
 //   consensus.powLimit = uint256S("0000000000000000000000000000000000000000000000000000000000000000");
//we are creating a fresh blockchain so no work should exist on any nodes since we have not deployed any yet???
        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
        consensus.nPowTargetSpacing = 10 * 60;
        consensus.fPowAllowMinDifficultyBlocks = false;
        consensus.fPowNoRetargeting = false;
        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016
        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008

        // Deployment of Taproot (BIPs 340-342)
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008

      //  consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000001533efd8d716a517fe2c5008");//old bitcoincore
 consensus.nMinimumChainWork = consensus.powLimit;
        //it's the minimum amount of total work a chain must have before the client considers it valid.
//В следующих двух строках указывается минимальный объем цепной работы, который должен выполнить клиент, прежде чем он будет считать себя синхронизированным. 
      //  its just like an amount of work that is needed, any chain that had that much work would be accepted. 
       // BUT it would be basically impossible to create a new chain with that much work, that's the point of PoW, 
        //so you're correct that you would need to modify that value if you want to run your own private network
        consensus.defaultAssumeValid = uint256S("0x00000000d0c68340079b33f213c1825928c1b956d11748267a6b0f9511712ce1"); //genesis hash clone 0 block
//строкa отключаeт проверку подписи для блоков, которые являются предками блока, указанного хэшем этого блока. 
        /**
         * The message start string is designed to be unlikely to occur in normal data.
         * The characters are rarely used upper ASCII, not valid as UTF-8, and produce
         * a large 32-bit integer with any alignment.
         */
       // pchMessageStart[0] = 0xf9;//old bitcoin
        pchMessageStart[0] = 0xec;//changed by clone
        pchMessageStart[1] = 0xbe;
        pchMessageStart[2] = 0xb4;
        pchMessageStart[3] = 0xd9;
        nDefaultPort = 8333;
        nPruneAfterHeight = 100000;
        m_assumed_blockchain_size = 5;
        m_assumed_chain_state_size = 6;

        genesis = CreateGenesisBlock(1609999061, 445019322, 0x1d00ffff, 1, 50 * COIN);//clone nTime nNonce
        consensus.hashGenesisBlock = genesis.GetHash();
        assert(consensus.hashGenesisBlock == uint256S("0x00000000d0c68340079b33f213c1825928c1b956d11748267a6b0f9511712ce1"));//clone hash
        assert(genesis.hashMerkleRoot == uint256S("0xf7c3ecddcb85e559a9339a3645a479607f9839ec4dfe314e95908f8fd8710533"));//clone genesis merklehash
vFixedSeeds.clear();//clone 0 seeds
        vSeeds.clear();//clone 0 seeds
        // Note that of those which support the service bits prefix, most only support a subset of
        // possible options.
        // This is fine at runtime as we'll fall back to using them as an addrfetch if they don't support the
        // service bits we want, but we should get them updated to support all service bits wanted by any
        // release ASAP to avoid it where possible.
       // vSeeds.emplace_back("seed.bitcoin.sipa.be"); //oldbitcoin Pieter Wuille, only supports x1, x5, x9, and xd
       // vSeeds.emplace_back("dnsseed.bluematt.me"); //oldbitcoin Matt Corallo, only supports x9
       // vSeeds.emplace_back("dnsseed.bitcoin.dashjr.org"); //oldbitcoin Luke Dashjr
       // vSeeds.emplace_back("seed.bitcoinstats.com"); //oldbitcoin Christian Decker, supports x1 - xf
       // vSeeds.emplace_back("seed.bitcoin.jonasschnelli.ch"); //oldbitcoin Jonas Schnelli, only supports x1, x5, x9, and xd
       // vSeeds.emplace_back("seed.btc.petertodd.org"); //oldbitcoin Peter Todd, only supports x1, x5, x9, and xd
       // vSeeds.emplace_back("seed.bitcoin.sprovoost.nl"); //oldbitcoin Sjors Provoost
       // vSeeds.emplace_back("dnsseed.emzy.de"); //oldbitcoin Stephan Oeste
      //  vSeeds.emplace_back("seed.bitcoin.wiz.biz"); //oldbitcoin Jason Maurice

        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);
        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);
        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);
        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x88, 0xB2, 0x1E};
        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x88, 0xAD, 0xE4};

        bech32_hrp = "bc";

        vFixedSeeds = std::vector<SeedSpec6>(std::begin(pnSeed6_main), std::end(pnSeed6_main));

        fDefaultConsistencyChecks = false;
        fRequireStandard = true;
        m_is_test_chain = false;
        m_is_mockable_chain = false;

        checkpointData = {
            {
                { 0, uint256S("0x00000000d0c68340079b33f213c1825928c1b956d11748267a6b0f9511712ce1")},//changed clone first block
            }
        };

        m_assumeutxo_data = MapAssumeutxo{
         // TODO to be specified in a future patch.
        };

             chainTxData = ChainTxData{
            // Data from RPC: getchaintxstats 4096 0000000000000000000b9d2ec5a352ecba0592946514a92f14319dc2b367fc72
            /* nTime    */ 1609999061,// unix timestamp of last know number of transactions
            /* nTxCount */ 0,//total number of transaction beetween genesis and that timestamp (the tx=.. number in the setbestchain debug.log lines)
            /* dTxRate  */ 0,//estimated number of transactions per second after that timestamp
        };
    }
};

/**
 * Testnet (v3)
 */
class CTestNetParams : public CChainParams {
public:
    CTestNetParams() {
        strNetworkID = CBaseChainParams::TESTNET;
        consensus.signet_blocks = false;
        consensus.signet_challenge.clear();
        consensus.nSubsidyHalvingInterval = 210000;
        consensus.BIP16Exception = uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88");//clone
        consensus.BIP34Height = 0;//clone
        consensus.BIP34Hash = uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88");//clone
        consensus.BIP65Height = 0; // clone
        consensus.CSVHeight = 0; // clone
        consensus.SegwitHeight = 834624; // clone save as is because not work in 0 or 1 block
        consensus.MinBIP9WarningHeight = 836640; // segwit activation height + miner confirmation window //clone
        consensus.powLimit = uint256S("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff");//clone
        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
        consensus.nPowTargetSpacing = 10 * 60;
        consensus.fPowAllowMinDifficultyBlocks = true;
        consensus.fPowNoRetargeting = false;
        consensus.nRuleChangeActivationThreshold = 1512; // 75% for testchains
        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008

        // Deployment of Taproot (BIPs 340-342)
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008

        consensus.nMinimumChainWork = consensus.powLimit;//clone
        consensus.defaultAssumeValid = uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88"); // clone hash genesis test block

        pchMessageStart[0] = 0x0c;//clone
        pchMessageStart[1] = 0x11;
        pchMessageStart[2] = 0x09;
        pchMessageStart[3] = 0x07;
        nDefaultPort = 18333;
        nPruneAfterHeight = 10000;
        m_assumed_blockchain_size = 40;
        m_assumed_chain_state_size = 2;

        genesis = CreateGenesisBlock(1609999060, 1884134833, 0x1d00ffff, 1, 50 * COIN);//clone
        consensus.hashGenesisBlock = genesis.GetHash();
        assert(consensus.hashGenesisBlock == uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88"));//clone
        assert(genesis.hashMerkleRoot == uint256S("0xf7c3ecddcb85e559a9339a3645a479607f9839ec4dfe314e95908f8fd8710533"));//clone

        vFixedSeeds.clear();
        vSeeds.clear();
        // nodes with support for servicebits filtering should be at the top
   //clone//     vSeeds.emplace_back("testnet-seed.bitcoin.jonasschnelli.ch");
  // clone//     vSeeds.emplace_back("seed.tbtc.petertodd.org");
    //clone//    vSeeds.emplace_back("seed.testnet.bitcoin.sprovoost.nl");
      //clone//  vSeeds.emplace_back("testnet-seed.bluematt.me"); // Just a static list of stable node(s), only supports x9

        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);
        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);
        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);
        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};
        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};

        bech32_hrp = "tb";

        vFixedSeeds = std::vector<SeedSpec6>(std::begin(pnSeed6_test), std::end(pnSeed6_test));

        fDefaultConsistencyChecks = false;
        fRequireStandard = false;
        m_is_test_chain = true;
        m_is_mockable_chain = false;

        checkpointData = {
            {
                {0, uint256S("00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88")},//clone
            }
        };

        m_assumeutxo_data = MapAssumeutxo{
            // TODO to be specified in a future patch.
        };

        chainTxData = ChainTxData{
            // Data from RPC: getchaintxstats 4096 000000000000006433d1efec504c53ca332b64963c425395515b01977bd7b3b0
            /* nTime    clone */ 1609999060,
            /* nTxCount clone */ 0,
            /* dTxRate clone  */ 0,
        };
    }
};

/**
 * Signet
 */
class SigNetParams : public CChainParams {
public:
    explicit SigNetParams(const ArgsManager& args) {
        std::vector<uint8_t> bin;
        vSeeds.clear();

        if (!args.IsArgSet("-signetchallenge")) {
            bin = ParseHex("512103ad5e0edad18cb1f0fc0d28a3d4f1f3e445640337489abb10404f2d1e086be430210359ef5021964fe22d6f8e05b2463c9540ce96883fe3b278760f048f5189f2e6c452ae");
            vSeeds.emplace_back("127.0.0.1");//clone
         //clone   vSeeds.emplace_back("2a01:7c8:d005:390::5");
         //clone   vSeeds.emplace_back("v7ajjeirttkbnt32wpy3c6w3emwnfr3fkla7hpxcfokr3ysd3kqtzmqd.onion:38333");

            consensus.nMinimumChainWork = uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88");//clone
            consensus.defaultAssumeValid = uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88"); // 0 clone
            m_assumed_blockchain_size = 1;
            m_assumed_chain_state_size = 0;
            chainTxData = ChainTxData{
                // Data from RPC: getchaintxstats 4096 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020
                /* nTime   clone */ 1609999060,
                /* nTxCount clone*/ 0,
                /* dTxRate  */ 0,
            };
        } else {
            const auto signet_challenge = args.GetArgs("-signetchallenge");
            if (signet_challenge.size() != 1) {
                throw std::runtime_error(strprintf("%s: -signetchallenge cannot be multiple values.", __func__));
            }
            bin = ParseHex(signet_challenge[0]);

            consensus.nMinimumChainWork = uint256{};
            consensus.defaultAssumeValid = uint256{};
            m_assumed_blockchain_size = 0;
            m_assumed_chain_state_size = 0;
            chainTxData = ChainTxData{
                0,
                0,
                0,
            };
            LogPrintf("Signet with challenge %s\n", signet_challenge[0]);
        }

        if (args.IsArgSet("-signetseednode")) {
            vSeeds = args.GetArgs("-signetseednode");
        }

        strNetworkID = CBaseChainParams::SIGNET;
        consensus.signet_blocks = true;
        consensus.signet_challenge.assign(bin.begin(), bin.end());
        consensus.nSubsidyHalvingInterval = 210000;
        consensus.BIP16Exception = uint256{};
        consensus.BIP34Height = 1;
        consensus.BIP34Hash = uint256{};
        consensus.BIP65Height = 1;
        consensus.BIP66Height = 1;
        consensus.CSVHeight = 1;
        consensus.SegwitHeight = 1;
        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
        consensus.nPowTargetSpacing = 10 * 60;
        consensus.fPowAllowMinDifficultyBlocks = false;
        consensus.fPowNoRetargeting = false;
        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016
        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing
        consensus.MinBIP9WarningHeight = 0;
        consensus.powLimit = uint256S("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008

        // Activation of Taproot (BIPs 340-342)
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;

        // message start is defined as the first 4 bytes of the sha256d of the block script
        CHashWriter h(SER_DISK, 0);
        h << consensus.signet_challenge;
        uint256 hash = h.GetHash();
        memcpy(pchMessageStart, hash.begin(), 4);

        nDefaultPort = 38333;
        nPruneAfterHeight = 1000;

        genesis = CreateGenesisBlock(1609999060, 1884134833, 0x1d00ffff, 1, 50 * COIN);//clone
        consensus.hashGenesisBlock = genesis.GetHash();
        assert(consensus.hashGenesisBlock == uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88"));//clone
        assert(genesis.hashMerkleRoot == uint256S("0xf7c3ecddcb85e559a9339a3645a479607f9839ec4dfe314e95908f8fd8710533"));//clone

        vFixedSeeds.clear();

        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);
        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);
        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);
        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};
        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};

        bech32_hrp = "tb";

        fDefaultConsistencyChecks = false;
        fRequireStandard = true;
        m_is_test_chain = true;
        m_is_mockable_chain = false;
    }
};

/**
 * Regression test
 */
class CRegTestParams : public CChainParams {
public:
    explicit CRegTestParams(const ArgsManager& args) {
        strNetworkID =  CBaseChainParams::REGTEST;
        consensus.signet_blocks = false;
        consensus.signet_challenge.clear();
        consensus.nSubsidyHalvingInterval = 150;
        consensus.BIP16Exception = uint256();
        consensus.BIP34Height = 500; // BIP34 activated on regtest (Used in functional tests)
        consensus.BIP34Hash = uint256();
        consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in functional tests)
        consensus.BIP66Height = 1251; // BIP66 activated on regtest (Used in functional tests)
        consensus.CSVHeight = 432; // CSV activated on regtest (Used in rpc activation tests)
        consensus.SegwitHeight = 150; // SEGWIT is always activated on regtest unless overridden
        consensus.MinBIP9WarningHeight = 0;
        consensus.powLimit = uint256S("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
        consensus.nPowTargetSpacing = 10 * 60;
        consensus.fPowAllowMinDifficultyBlocks = true;
        consensus.fPowNoRetargeting = true;
        consensus.nRuleChangeActivationThreshold = 108; // 75% for testchains
        consensus.nMinerConfirmationWindow = 144; // Faster than normal for regtest (144 instead of 2016)
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;
        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;
        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;

        consensus.nMinimumChainWork = uint256{};
        consensus.defaultAssumeValid = uint256{};

        pchMessageStart[0] = 0xfa;
        pchMessageStart[1] = 0xbc;//clon
        pchMessageStart[2] = 0xb5;
        pchMessageStart[3] = 0xda;
        nDefaultPort = 18444;
        nPruneAfterHeight = gArgs.GetBoolArg("-fastprune", false) ? 100 : 1000;
        m_assumed_blockchain_size = 0;
        m_assumed_chain_state_size = 0;

        UpdateActivationParametersFromArgs(args);

        genesis = CreateGenesisBlock(1609999060, 1884134833, 0x1d00ffff, 1, 50 * COIN);//clone
        consensus.hashGenesisBlock = genesis.GetHash();
        assert(consensus.hashGenesisBlock == uint256S("0x00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88"));//clone
        assert(genesis.hashMerkleRoot == uint256S("0xf7c3ecddcb85e559a9339a3645a479607f9839ec4dfe314e95908f8fd8710533"));//clone

        vFixedSeeds.clear(); //!< Regtest mode doesn't have any fixed seeds.
        vSeeds.clear();      //!< Regtest mode doesn't have any DNS seeds.

        fDefaultConsistencyChecks = true;
        fRequireStandard = true;
        m_is_test_chain = true;
        m_is_mockable_chain = true;

        checkpointData = {
            {
                {0, uint256S("00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88")},//clone
            }
        };

        m_assumeutxo_data = MapAssumeutxo{
      //clone      {
       //         110,
    //            {uint256S("0x76fd7334ac7c1baf57ddc0c626f073a655a35d98a4258cd1382c8cc2b8392e10"), 110},
       //     },
       //     {
       //         210,
       //         {uint256S("0x9c5ed99ef98544b34f8920b6d1802f72ac28ae6e2bd2bd4c316ff10c230df3f2"), 210},
        //    },
        };

        chainTxData = ChainTxData{
            0,
            0,
            0
        };

        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);
        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);
        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);
        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};
        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};

        bech32_hrp = "bcrt";
    }

    /**
     * Allows modifying the Version Bits regtest parameters.
     */
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
    {
        consensus.vDeployments[d].nStartTime = nStartTime;
        consensus.vDeployments[d].nTimeout = nTimeout;
    }
    void UpdateActivationParametersFromArgs(const ArgsManager& args);
};

void CRegTestParams::UpdateActivationParametersFromArgs(const ArgsManager& args)
{
    if (args.IsArgSet("-segwitheight")) {
        int64_t height = args.GetArg("-segwitheight", consensus.SegwitHeight);
        if (height < -1 || height >= std::numeric_limits<int>::max()) {
            throw std::runtime_error(strprintf("Activation height %ld for segwit is out of valid range. Use -1 to disable segwit.", height));
        } else if (height == -1) {
            LogPrintf("Segwit disabled for testing\n");
            height = std::numeric_limits<int>::max();
        }
        consensus.SegwitHeight = static_cast<int>(height);
    }

    if (!args.IsArgSet("-vbparams")) return;

    for (const std::string& strDeployment : args.GetArgs("-vbparams")) {
        std::vector<std::string> vDeploymentParams;
        boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
        if (vDeploymentParams.size() != 3) {
            throw std::runtime_error("Version bits parameters malformed, expecting deployment:start:end");
        }
        int64_t nStartTime, nTimeout;
        if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
            throw std::runtime_error(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
        }
        if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
            throw std::runtime_error(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
        }
        bool found = false;
        for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
            if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) {
                UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                found = true;
                LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                break;
            }
        }
        if (!found) {
            throw std::runtime_error(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
        }
    }
}

static std::unique_ptr<const CChainParams> globalChainParams;

const CChainParams &Params() {
    assert(globalChainParams);
    return *globalChainParams;
}

std::unique_ptr<const CChainParams> CreateChainParams(const ArgsManager& args, const std::string& chain)
{
    if (chain == CBaseChainParams::MAIN) {
        return std::unique_ptr<CChainParams>(new CMainParams());
    } else if (chain == CBaseChainParams::TESTNET) {
        return std::unique_ptr<CChainParams>(new CTestNetParams());
    } else if (chain == CBaseChainParams::SIGNET) {
        return std::unique_ptr<CChainParams>(new SigNetParams(args));
    } else if (chain == CBaseChainParams::REGTEST) {
        return std::unique_ptr<CChainParams>(new CRegTestParams(args));
    }
    throw std::runtime_error(strprintf("%s: Unknown chain %s.", __func__, chain));
}

void SelectParams(const std::string& network)
{
    SelectBaseParams(network);
    globalChainParams = CreateChainParams(gArgs, network);
}

std::ostream& operator<<(std::ostream& o, const AssumeutxoData& aud)
{
    o << strprintf("AssumeutxoData(%s, %s)", aud.hash_serialized.ToString(), aud.nChainTx);
    return o;
}



---generating 0 block

python genesis.py -z "Financial independent.A counterbalance to the global debt grow has been found.." -n 140620 -t 1609999061 -p 04127af709c0738b33490059eb2c801199d4e9156eefd64082b948aed4fbf6db0d5272a21df1f5c9e74802dba32ba5574fbe9fec24d6811c3b16d1ad6055909af9 -v 5000000000
04ffff001d01044c4f46696e616e6369616c20696e646570656e64656e742e4120636f756e74657262616c616e636520746f2074686520676c6f62616c20646562742067726f7720686173206265656e20666f756e642e2e
algorithm: SHA256
merkle hash: f7c3ecddcb85e559a9339a3645a479607f9839ec4dfe314e95908f8fd8710533
pszTimestamp: Financial independent.A counterbalance to the global debt grow has been found..
pubkey: 04127af709c0738b33490059eb2c801199d4e9156eefd64082b948aed4fbf6db0d5272a21df1f5c9e74802dba32ba5574fbe9fec24d6811c3b16d1ad6055909af9
time: 1609999061
bits: 0x1d00ffff
Searching for genesis hash..
144746.0 hash/s, estimate: 8.2 hgenesis hash found!
nonce: 445019322
genesis hash: 00000000d0c68340079b33f213c1825928c1b956d11748267a6b0f9511712ce1


second
python genesis.py -z "Financial independent.A counterbalance to the global debt grow has been found.." -n 2 -t 1609999060 -p 04127af709c0738b33490059eb2c801199d4e9156eefd64082b948aed4fbf6db0d5272a21df1f5c9e74802dba32ba5574fbe9fec24d6811c3b16d1ad6055909af9 -v 5000000000
04ffff001d01044c4f46696e616e6369616c20696e646570656e64656e742e4120636f756e74657262616c616e636520746f2074686520676c6f62616c20646562742067726f7720686173206265656e20666f756e642e2e
algorithm: SHA256
merkle hash: f7c3ecddcb85e559a9339a3645a479607f9839ec4dfe314e95908f8fd8710533
pszTimestamp: Financial independent.A counterbalance to the global debt grow has been found..
pubkey: 04127af709c0738b33490059eb2c801199d4e9156eefd64082b948aed4fbf6db0d5272a21df1f5c9e74802dba32ba5574fbe9fec24d6811c3b16d1ad6055909af9
time: 1609999060
bits: 0x1d00ffff
Searching for genesis hash..
140963.0 hash/s, estimate: 8.5 hgenesis hash found!
nonce: 1884134833
genesis hash: 00000000f462bebc500d0721063d06304801777a99b840a3a06732ac9a93aa88




after download srccodefrom bitcoincore
 1)replace file chainparams.cpp
2)find .-type sed BTC/B3C/
3)replace new yours node list host in contrib/seeds  main.txt & test.txt filse  .use script py in contrib/seeds for prepare ip to 3.1
python3 generate-seeds.py .> ../../src/chainparamsseeds.h
3.1) проверить chainparamsseeds.h вписались ли свои ноды 
4)исправить переменные  на core clone в скрипте configure.ac
4.1)снимем защиту разработчиков от синхронизации нового блокчейна 
static constexpr int64_t MAX_BLOCK_TIME_GAP = 30600 * 365;

 5)запустить сборку зависимостей потом конфигурашию для нужной системы и компиляцию*

*build linux static

I assume you just want to create a Linux binary that can be used on all systems without installing all dependencies. To do that, you can use Bitcoin Core's depends system. Instructions are here: https://github.com/bitcoin/bitcoin/tree/master/depends.
Basically, all you need to do is (starting from the source root directory):
cd depends
make
cd ..
./configure --prefix=`pwd`/depends/x86_64-linux-gnu # Actually check what folder is created in depends after you built the dependencies and use that instead
make
Once you do that, the binaries that are produced can be moved to and used on any linux system. The binaries are located at (from the source root dir) src/bitcoind, src/qt/bitcoin-qt, src/bitcoin-cli, and src/bitcoin-tx



*in linux built for windows instruction
cd depends
make HOST=x86_64-w64-mingw32

cd ..

CONFIG_SITE=$PWD/depends/x86_64-w64-mingw32/share/config.site
./configure --prefix=`pwd`/depends/x86_64-w64-mingw32


make

6)проверить переменные с  clone в созданном src/config/bitcoinconfig.h
а также 
client version release   true
  втомже файле чтобы не появлялось сообщение тестовая сборка




for creating dns seeders and after paste them to chainparams.cpp use software github.com/ sipa/bitcoin-seeder 
